            }
            
            // Rule 9: Cap extreme values but keep absurd
            if (points > 100) points = Math.floor(points * 0.7);
            if (points < -100) points = Math.floor(points * 0.7);
            
            // Rule 10: Sometimes just a random number
            if (Math.random() < 0.05) {
                points = Math.floor(Math.random() * 200) - 100;
            }
            
            return points;
        }
        
        // ABSURD PATIENCE BONUS CALCULATION
        function calculateAbsurdPatienceBonus() {
            let bonus = 20; // Base
            
            // Rule 1: Time-based bonus
            if (time % 7 === 0) bonus += 10;
            
            // Rule 2: Score-based bonus
            if (Math.abs(score) > 100) bonus += 5;
            
            // Rule 3: Push count bonus
            if (pushes % 5 === 0) bonus += 15;
            
            // Rule 4: Random factor
            bonus += Math.floor(Math.random() * 10) - 5;
            
            // Rule 5: Special conditions
            if (patience < 30) bonus += 10; // Low patience boost
            if (pushStreak > 2) bonus -= 5; // Streak penalty
            
            return Math.max(5, Math.min(50, bonus));
        }
        
        // ABSURD PATIENCE PENALTY CALCULATION
        function calculateAbsurdPatiencePenalty() {
            let penalty = 10; // Base
            
            // Rule 1: Time-based penalty
            if (time % 11 === 0) penalty += 8;
            
            // Rule 2: Score-based penalty
            if (score < 0) penalty += 5;
            
            // Rule 3: Push count penalty
            if (pushes % 3 === 0) penalty += 7;
            
            // Rule 4: Random factor
            penalty += Math.floor(Math.random() * 8) - 4;
            
            // Rule 5: Special conditions
            if (patience > 70) penalty += 3; // High patience extra penalty
            if (pushStreak > 1) penalty += pushStreak * 2; // Streak penalty
            
            return Math.max(5, Math.min(30, penalty));
        }
        
        // Helper functions for absurd rules
        function isPrime(num) {
            if (num <= 1) return false;
            if (num <= 3) return true;
            if (num % 2 === 0 || num % 3 === 0) return false;
            for (let i = 5; i * i <= num; i += 6) {
                if (num % i === 0 || num % (i + 2) === 0) return false;
            }
            return true;
        }
        
        function isFibonacci(num) {
            if (num === 0 || num === 1) return true;
            let a = 0, b = 1, c = 1;
            while (c < num) {
                c = a + b;
                a = b;
                b = c;
            }
            return c === num;
        }
        
        // Random messages for absurdity
        function getRandomSuccessMessage() {
            const messages = [
                "Pushed back!", "Nice one!", "He sat down!", "Couch victory!",
                "Sitting achieved!", "Not standing!", "Couch secured!", "Success!",
                "He's sitting!", "Couch maintained!", "Position held!", "Good push!"
            ];
            return messages[Math.floor(Math.random() * messages.length)];
        }
        
        function getRandomAnnoyingMessage() {
            const messages = [
                "Why push?", "Unnecessary...", "He was sitting!", "Pointless push",
                "Already sitting!", "No need for that!", "Why bother?", "Sitting fine",
                "No standing here!", "Couch occupied!", "He's comfortable!", "No movement needed"
            ];
            return messages[Math.floor(Math.random() * messages.length)];
        }
        
        function formatPoints(points) {
            if (points > 0) return `+${points}`;
            if (points < 0) return `${points}`;
            return "0";
        }
        
        // Check for special time-based events
        function checkTimeEvents() {
            // Rule: Every 30 seconds, something special
            if (time % 30 === 0 && time > 0) {
                const events = [
                    { name: "Time warp!", effect: () => { patience += 15; showNotification("â° Time warp! +15 patience"); } },
                    { name: "Score shuffle!", effect: () => { score = Math.floor(score * (Math.random() > 0.5 ? 1.2 : 0.8)); updateScoreDisplay(); showNotification("ðŸ”€ Score shuffled!"); } },
                    { name: "Patience reset!", effect: () => { patience = 50; updatePatienceBar(); showNotification("ðŸ”„ Patience reset to 50%"); } }
                ];
                const event = events[Math.floor(Math.random() * events.length)];
                event.effect();
            }
            
            // Rule: Every 13 seconds, something weird
            if (time % 13 === 0 && time > 0) {
                showNotification("ðŸ‘» 13 seconds... something feels weird");
            }
        }
        
        // Check for special push events
        function checkPushEvents() {
            // Rule: Every 7th push
            if (pushes % 7 === 0 && pushes > 0) {
                showNotification("ðŸŽ± 7th push! Lucky number?");
            }
            
            // Rule: Every 100 points milestone
            if (Math.abs(score) % 100 < 10 && Math.abs(score) > 90) {
                showNotification(`ðŸŽ¯ ${score > 0 ? 'Positive' : 'Negative'} ${Math.abs(score)} points!`);
            }
            
            // Rule: Prime number of attempts
            if (isPrime(attempts) && attempts > 1) {
                showNotification(`ðŸ”¢ Prime attempt ${attempts}!`);
            }
        }
        
        // Update score display with visual effects
        function updateScoreDisplay() {
            scoreEl.textContent = score;
            
            // Color coding with transitions
            if (score > 0) {
                scoreEl.className = 'score positive';
                scoreEl.style.textShadow = '0 0 10px rgba(78, 205, 196, 0.5)';
            } else if (score < 0) {
                scoreEl.className = 'score negative';
                scoreEl.style.textShadow = '0 0 10px rgba(255, 107, 107, 0.5)';
            } else {
                scoreEl.className = 'score zero';
                scoreEl.style.textShadow = 'none';
            }
            
            // Animation for score change
            scoreEl.style.transform = 'scale(1.1)';
            setTimeout(() => {
                scoreEl.style.transform = 'scale(1)';
            }, 200);
        }
        
        // Update patience bar
        function updatePatienceBar() {
            patienceBarEl.style.width = patience + '%';
            
            // Color coding
            if (patience > 50) {
                patienceBarEl.style.background = '#4ecdc4';
            } else if (patience > 20) {
                patienceBarEl.style.background = '#ffd93d';
            } else {
                patienceBarEl.style.background = '#ff6b6b';
            }
        }
        
        // End game
        function endGame(reason) {
            gameOver = true;
            isPlaying = false;
            isTryingToStand = false;
            
            // Show escaped person
            personEl.className = 'person';
            personEl.textContent = 'ðŸƒâ€â™‚ï¸';
            
            // Show game over screen
            finalScoreEl.textContent = score;
            finalTimeEl.textContent = time + 's';
            finalPushesEl.textContent = pushes;
            gameOverEl.style.display = 'flex';
            
            // Final absurd message
            const finalMessages = [
                "He stood up! Game over!",
                "Escaped! The couch is empty!",
                "He's gone! You lost!",
                "Standing achieved! You failed!",
                "Couch abandoned! Game over!"
            ];
            showNotification(finalMessages[Math.floor(Math.random() * finalMessages.length)]);
            
            console.log(`ðŸƒâ€â™‚ï¸ GAME OVER: ${reason}`);
        }
        
        // Reset game
        function resetGame() {
            startGame();
            showNotification("ðŸ”„ Game reset! Starting over!");
        }
        
        // Show notification
        function showNotification(message) {
            console.log(message);
            notificationEl.textContent = message;
            notificationEl.style.display = 'block';
            
            setTimeout(() => {
                notificationEl.style.display = 'none';
            }, 3000);
        }
        
        // Start when page loads - NO START BUTTON NEEDED!
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>